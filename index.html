<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VEX</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --square-width: 100px;
            --square-height: 100px;
            --robot-heading: 0deg;
            --robot-x: 50%;
            --robot-y: 50%;
            --px-per-ft: 50;
            --bg: #0b1017;
            --panel: #0f1724;
            --muted: #7c869a;
            --border: #1f2a3d;
            --accent: #3cbf8a;
            --accent-strong: #27a06f;
            --card: #121c2b;
            --text: #e5ecf5;
            --danger: #f15b5b;
        }
        body {
            background: radial-gradient(circle at 20% 20%, rgba(60, 191, 138, 0.08), transparent 25%),
                        radial-gradient(circle at 80% 0%, rgba(124, 134, 154, 0.08), transparent 20%),
                        var(--bg);
            color: var(--text);
            font-family: 'Manrope', 'Segoe UI', sans-serif;
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            padding: 24px;
            box-sizing: border-box;
        }
        .app-shell {
            width: 100%;
            max-width: 1440px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-height: 100vh;
            justify-content: space-between;
        }
        .masthead {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }
        .brand {
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }
        .badge {
            padding: 6px 10px;
            background: rgba(60, 191, 138, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
            border-radius: 8px;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }
        .control-slab {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            align-items: end;
        }
        .field-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .field-group label {
            font-size: 12px;
            color: var(--muted);
            letter-spacing: 0.2px;
        }
        .field-group input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-weight: 600;
            outline: none;
            transition: border 0.15s ease, background 0.15s ease;
        }
        .field-group input:focus {
            border-color: var(--accent);
            background: #0f1a28;
        }
        .button-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }
        button {
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: linear-gradient(135deg, var(--accent), var(--accent-strong));
            color: #05140e;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.15s ease;
        }
        button:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(60, 191, 138, 0.25); }
        button:active { transform: translateY(0); }
        button.secondary {
            background: var(--card);
            color: var(--text);
            border-color: var(--border);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        }
        button.secondary:hover { border-color: var(--accent); }
        button.danger {
            background: linear-gradient(135deg, #f77676, var(--danger));
            color: #2b0b0b;
            border-color: #f77676;
        }
        .file-button {
            display: block;
            text-align: center;
            cursor: pointer;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-weight: 700;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        }
        .file-button:hover { border-color: var(--accent); }
        .file-button input { display: none; }
        .workspace {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 16px;
        }
        .canvas-wrap {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }
        .field-mode-toggle {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 3;
            display: flex;
            gap: 8px;
        }
        .toggle-btn {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }
        .toggle-btn:hover { transform: translateY(-1px); box-shadow: 0 8px 16px rgba(60, 191, 138, 0.18); border-color: var(--accent); }
        .toggle-btn.active { background: rgba(60, 191, 138, 0.12); border-color: var(--accent); color: var(--accent); }
        #match_field {
            position: relative;
            width: 600px;
            height: 600px;
            background-image: url('./vex_skills_field.jpg');
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin: 0 auto;
        }
        #path-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 1;
        }
        .waypoint-overlay {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .waypoint {
            position: absolute;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(60, 191, 138, 0.9);
            border-radius: 50%;
            background: rgba(60, 191, 138, 0.3);
            cursor: grab;
            transform: translate(-50%, -50%);
            user-select: none;
            transition: transform 0.1s ease, box-shadow 0.15s ease;
        }
        .waypoint:hover { transform: translate(-50%, -50%) scale(1.08); box-shadow: 0 0 12px rgba(60, 191, 138, 0.8); }
        .waypoint.dragging {
            background: rgba(255, 174, 94, 0.9);
            border-color: rgba(255, 174, 94, 1);
            cursor: grabbing;
        }
        .robot {
            position: absolute;
            width: var(--square-width);
            height: var(--square-height);
            left: var(--robot-x);
            top: var(--robot-y);
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        .robot-container { position: relative; width: 100%; height: 100%; pointer-events: auto; }
        .robot-body {
            width: 100%;
            height: 100%;
            border: 3px solid rgba(60, 191, 138, 0.9);
            background: rgba(60, 191, 138, 0.08);
            position: relative;
            box-sizing: border-box;
            transform: rotate(var(--robot-heading));
            border-radius: 6px;
        }
        .robot-front-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 18px;
            height: 26px;
            /* Arrow inherits rotation from the robot body (no extra rotate here).
               The arrow element is positioned in the center and will point
               in the robot's forward direction because the parent `.robot-body`
               applies the `--robot-heading` transform. */
            transform: translate(-50%, -50%);
            cursor: grab;
        }
        .robot-front-arrow.reversed {
            /* When driving reversed, flip the arrow 180deg so it points backwards
               relative to the robot body. */
            transform: translate(-50%, -50%) rotate(180deg);
        }
        .robot-front-arrow::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 9px solid transparent;
            border-right: 9px solid transparent;
            border-bottom: 12px solid rgba(255, 174, 94, 0.95);
            transform: translateX(-50%);
        }
        .robot-front-arrow::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 50%;
            width: 5px;
            height: 16px;
            background: rgba(255, 174, 94, 0.95);
            transform: translateX(-50%);
        }
        .robot-front-arrow:active { cursor: grabbing; }
        .data-display {
            margin-top: 12px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
            font-family: monospace;
            color: var(--muted);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02);
        }
        .waypoints-panel {
            position: sticky;
            top: 24px;
            align-self: start;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }
        .waypoints-panel h3 {
            margin: 0;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--muted);
            letter-spacing: 0.2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .waypoints-panel h3 button {
            padding: 6px 12px;
            font-size: 11px;
        }
        .path-section {
            background: var(--panel);
            border-bottom: 1px solid var(--border);
        }
        .path-section:last-child { border-bottom: none; }
        .path-header {
            padding: 12px 14px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background 0.15s ease, border 0.15s ease;
        }
        .path-header.highlighted {
            background: rgba(60, 191, 138, 0.12);
            border-left: 3px solid var(--accent);
        }
        .path-header:hover { background: #141f2f; }
        .path-header-left { display: flex; align-items: center; gap: 10px; flex: 1; }
        .path-header-controls { display: flex; gap: 8px; align-items: center; }
        .path-header-controls button { padding: 8px 10px; font-size: 11px; }
        .path-header-controls button.delete { background: linear-gradient(135deg, #ff8f8f, #f15b5b); color: #2b0b0b; border-color: #ff8f8f; }
        .path-title { color: var(--text); font-weight: 700; font-size: 14px; }
        .path-toggle { color: var(--muted); transition: transform 0.2s ease; }
        .path-toggle.expanded { transform: rotate(90deg); }
        .path-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .path-content.expanded { max-height: 2000px; }
        .waypoint-item {
            background: var(--card);
            padding: 10px;
            margin: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-size: 11px;
            word-break: break-word;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .waypoint-item:hover { border-color: var(--accent); }
        .waypoint-item.highlighted {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(60, 191, 138, 0.4);
        }
        .waypoint-item-controls { margin-top: 8px; display: flex; gap: 6px; }
        .waypoint-item-controls button { padding: 6px 8px; font-size: 10px; }
        .waypoint-item-controls button.delete { background: linear-gradient(135deg, #ff8f8f, #f15b5b); color: #2b0b0b; border-color: #ff8f8f; }
        .waypoint.highlighted { border-color: rgba(255, 200, 0, 1); background: rgba(255, 200, 0, 0.5); box-shadow: 0 0 15px rgba(255, 200, 0, 0.8); }
        .waypoint-item-number { color: var(--accent); font-weight: 700; margin-bottom: 5px; }
        .waypoint-item-angle { color: rgba(255, 174, 94, 0.9); margin-top: 5px; font-size: 10px; }
        .waypoint-item-angle input[type="number"] {
            width: 72px;
            padding: 6px 8px;
            margin-left: 6px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: #0f1a28;
            color: var(--text);
            font-weight: 700;
            font-size: 12px;
            text-align: right;
            box-sizing: border-box;
        }
        .waypoint-item-angle input[type="number"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 4px rgba(39,160,111,0.06);
        }
        .waypoint-item-angle input[type="number"]::-webkit-outer-spin-button,
        .waypoint-item-angle input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9998;
        }
        .modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .modal {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .modal h2 {
            margin: 0;
            color: var(--text);
            font-size: 18px;
        }
        .modal textarea {
            width: 100%;
            height: 400px;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-family: monospace;
            font-size: 11px;
            resize: vertical;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .modal-actions button {
            padding: 10px 16px;
            border-radius: 8px;
        }
        .delay-input-container {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-top: 6px;
        }
        .delay-input-container label {
            font-size: 10px;
            color: var(--muted);
        }
        .delay-input-container input {
            width: 60px;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 10px;
        }
        .motor-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        .motor-section h4 {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .motor-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        .motor-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .motor-group h5 {
            margin: 0;
            font-size: 12px;
            color: var(--text);
            font-weight: 600;
        }
        .motor-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .motor-buttons button {
            padding: 10px;
            font-size: 11px;
        }
        button.intake-forward {
            background: linear-gradient(135deg, #4a9eff, #2a7edf);
            border-color: #4a9eff;
            color: #fff;
        }
        button.intake-reverse {
            background: linear-gradient(135deg, #ff6b6b, #cc5555);
            border-color: #ff6b6b;
            color: #fff;
        }
        button.outtake-forward {
            background: linear-gradient(135deg, #ffa500, #e68a00);
            border-color: #ffa500;
            color: #fff;
        }
        button.outtake-reverse {
            background: linear-gradient(135deg, #9d4edd, #7a2fa0);
            border-color: #9d4edd;
            color: #fff;
        }
        @media (max-width: 1100px) { .workspace { grid-template-columns: 1fr; } #match_field { max-width: 100%; } }
        footer {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 16px;
            text-align: center;
            color: var(--muted);
            font-size: 11px;
            line-height: 1.4;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            margin-top: 16px;
        }
        footer p {
            margin: 2px 0;
        }
        /* Debug overlay (visible during development) */
        #debug-overlay {
            position: fixed;
            right: 12px;
            bottom: 12px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            font-family: monospace;
            font-size: 12px;
            padding: 8px 10px;
            border-radius: 8px;
            z-index: 9999;
            max-width: 300px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="app-shell">
        <div class="masthead">
            <div class="brand">VEX Path Studio</div>
            <div class="badge">Beta</div>
        </div>

        <div class="control-slab">
            <div class="controls">
                <div class="field-group">
                    <label>X (in)</label>
                    <input type="number" id="x-input-ft" value="27.7" step="1" min="0" max="144">
                </div>
                <div class="field-group">
                    <label>Y (in)</label>
                    <input type="number" id="y-input-ft" value="88.5" step="1" min="0" max="144">
                </div>
                <div class="field-group">
                    <label>Heading (°)</label>
                    <input type="number" id="heading-input" value="0" min="0" max="360" step="1">
                </div>
                <div class="field-group" style="align-self: flex-end;">
                    <button class="secondary" onclick="rotate180()" style="padding: 10px; margin: 0;">Rotate 180°</button>
                </div>
                <div class="field-group">
                    <label>Width (in)</label>
                    <input type="number" id="size-width-in" value="15" step="0.5" min="5" max="48">
                </div>
                <div class="field-group">
                    <label>Height (in)</label>
                    <input type="number" id="size-height-in" value="15" step="0.5" min="5" max="48">
                </div>
                <div class="field-group">
                    <label>Speed (in/s)</label>
                    <input type="number" id="speed-input-ft" value="10" step="0.5" min="3" max="120">
                </div>
                <div class="field-group">
                    <label>IMU Offset (in)</label>
                    <input type="number" id="imu-offset" value="0" step="0.25" min="-12" max="12" title="Distance from robot center to IMU (forward is positive)">
                </div>
                <div class="field-group" style="align-self: center;">
                    <label style="display: flex; gap: 8px; align-items: center; color: var(--text); font-weight: 600;">
                        <input type="checkbox" id="show-waypoints" checked> Show waypoints
                    </label>
                </div>
            </div>
            <div class="button-row" style="margin-top: 12px;">
                <button onclick="updateRobot()">Update Robot</button>
                <button id="draw-btn" onclick="toggleDrawMode()">Draw Path</button>
                <button class="secondary" onclick="newPath()">New Path</button>
                <button class="danger" onclick="clearPath()">Clear Current</button>
            </div>
            <div class="button-row" style="margin-top: 10px;">
                <button class="secondary" onclick="exportData()">Export</button>
                <label class="file-button secondary" for="file-upload">Import
                    <input type="file" id="file-upload" accept=".json" onchange="importData(event)">
                </label>
                <button onclick="generateCppCode()">Generate C++ Code</button>
                <button onclick="startRun()">Run</button>
                <button class="secondary" onclick="pauseRun()">Pause</button>
                <button class="secondary" onclick="resetRun()">Reset</button>
            </div>
            <div class="button-row" style="margin-top: 10px; grid-template-columns: 1fr 1fr 1fr 1fr 1fr;">
                <input id="preset-name" type="text" placeholder="Preset name" style="padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: var(--card); color: var(--text); font-weight: 600;" />
                <select id="preset-select" style="padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: var(--card); color: var(--text); font-weight: 600;">
                    <option value="">Select preset</option>
                </select>
                <button class="secondary" onclick="savePreset()">Save Preset</button>
                <button class="secondary" onclick="loadPreset()">Load Preset</button>
                <button class="danger" onclick="deletePreset()">Delete Preset</button>
            </div>
        </div>

        <div class="workspace">
            <div class="canvas-wrap">
                <div class="field-mode-toggle" role="group" aria-label="Field Mode">
                    <button class="toggle-btn" id="mode-match">Match</button>
                    <button class="toggle-btn active" id="mode-skills">Skills</button>
                </div>
                <div id="match_field">
                    <div id="timer-display" style="display: none; position: absolute; top: 16px; right: 16px; z-index: 4; padding: 12px 16px; border-radius: 10px; border: 2px solid var(--border); background: var(--card); color: var(--text); font-weight: 700; text-align: center; font-size: 28px; min-width: 100px;">0:00</div>
                    <canvas id="path-canvas" width="600" height="600"></canvas>
                    <div class="waypoint-overlay" id="waypoint-overlay"></div>
                    <div class="robot">
                        <div class="robot-container">
                            <div class="robot-body">
                                <div class="robot-front-arrow" id="front-arrow"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="data-display">
                    <div id="data-output">Robot: (26.40 in, 87.60 in) @ 90° | Size: 12.00 x 12.00 in | Waypoints: 0</div>
                </div>
            </div>

            <div class="waypoints-panel" id="waypoints-panel">
                <h3>
                    <span>Paths</span>
                    <button onclick="newPath()" title="Create a new path">New Path</button>
                </h3>
                <div id="paths-container"></div>
            </div>
        </div>

        <footer>
            <p>&copy; 2025 Stratford Robotics 29295. All rights reserved.</p>
            <p>Developed by Om Patel</p>
        </footer>
    </div>

    <!-- Debug overlay for development: shows computed headings and angles -->
    <div id="debug-overlay" aria-hidden="false">Debug overlay</div>

    <!-- Code Display Modal -->
    <div class="modal-overlay" id="code-modal">
        <div class="modal">
            <h2>Generated C++ Code</h2>
            <textarea id="code-textarea" readonly></textarea>
            <div class="modal-actions">
                <button onclick="copyCodeToClipboard()">Copy to Clipboard</button>
                <button class="secondary" onclick="closeCodeModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        /*
         Main application script for VEX Path Studio.
         - Manages field rendering, waypoint creation and editing
         - Draws paths and renders them on a canvas overlay
         - Generates C++ path code, exports/imports JSON presets
         - Provides simple run/playback visualization of paths
        */
        const field = document.getElementById('match_field');
        const canvas = document.getElementById('path-canvas');
        const ctx = canvas.getContext('2d');
        const waypointOverlay = document.getElementById('waypoint-overlay');
        const FIELD_IMAGES = { match: './vex_match_field.png', skills: './vex_skills_field.jpg' };
        let fieldMode = 'skills';
        // Normalize an angle (degrees) into the range [-180, 180].
        // This is used to compare headings in a consistent representation.
        const normalizeHeading = (h) => {
            const n = ((h % 360) + 360) % 360;
            return n > 180 ? n - 360 : n;
        };
        function setFieldMode(mode) {
            fieldMode = mode;
            const matchBtn = document.getElementById('mode-match');
            const skillsBtn = document.getElementById('mode-skills');
            if (mode === 'match') {
                field.style.backgroundImage = `url('${FIELD_IMAGES.match}')`;
                matchBtn.classList.add('active');
                skillsBtn.classList.remove('active');
            } else {
                field.style.backgroundImage = `url('${FIELD_IMAGES.skills}')`;
                skillsBtn.classList.add('active');
                matchBtn.classList.remove('active');
            }
        }
        document.getElementById('mode-match').addEventListener('click', () => setFieldMode('match'));
        document.getElementById('mode-skills').addEventListener('click', () => setFieldMode('skills'));
        // Compute pixels-per-inch from the canvas width and the measured field inches.
        // Measured field width (accounting for image perspective): 133 inches.
        const FIELD_INCHES = 133;
        const FIELD_PX = (canvas && canvas.width) ? canvas.width : 600;
        const PX_PER_IN = FIELD_PX / FIELD_INCHES; // px per inch based on measured image
        const PX_PER_FT = PX_PER_IN * 12;
        const HEADING_ZERO_OFFSET = 180; // input 0° = visual left (standard 180°)
        // Calibrated offsets (auto-applied; no user input)
        let xOffsetCal = 4;
        let yOffsetCal = 0.5;
        const getXOffset = () => xOffsetCal;
        const getYOffset = () => yOffsetCal;
        
        let isDrawingPath = false;
        let pathPoints = [];
        let savedPaths = [];
        let robotHistory = [];
        let arrowDragging = false;
        let draggingWaypoint = null;
        let highlightedWaypoint = null;
        let highlightedPath = null;
        let lastRobotPos = { x: 300, y: 300, heading: 0 };

        // Calibration offset (in inches) to account for measured distance error
        // Set to +2 to correct a 2" discrepancy observed in real-life testing.
        // Positive values make displayed distances larger by that many inches.
        let distanceOffsetIn = 2;

        function pxToIn(px) { return (px / PX_PER_IN + distanceOffsetIn).toFixed(2); }
        function inToPx(inches) { return (inches - distanceOffsetIn) * PX_PER_IN; }
        function ftToPx(ft) { return ft * PX_PER_FT; } // legacy support

        function openCodeModal(code) {
            document.getElementById('code-textarea').value = code;
            document.getElementById('code-modal').classList.add('active');
        }

        function closeCodeModal() {
            document.getElementById('code-modal').classList.remove('active');
        }

        function copyCodeToClipboard() {
            const textarea = document.getElementById('code-textarea');
            textarea.select();
            document.execCommand('copy');
            alert('Code copied to clipboard!');
        }

        // Close modal when clicking outside
        document.getElementById('code-modal').addEventListener('click', (e) => {
            if (e.target.id === 'code-modal') {
                closeCodeModal();
            }
        });

        function setWaypointDelay(idx, delaySec) {
            if (!pathPoints[idx]) return;
            pathPoints[idx].delay = Math.max(0, parseFloat(delaySec) || 0) * 1000; // Convert seconds to ms
            renderWaypoints();
            updateDataDisplay();
        }

        function setWaypointAngle(idx, ang) {
            if (!pathPoints[idx]) return;
            if (ang === '' || ang === null) {
                delete pathPoints[idx].angleOverride;
            } else {
                const v = Number(parseFloat(ang));
                if (!Number.isNaN(v)) {
                    // Store as relative turn (degrees) to one decimal place
                    pathPoints[idx].angleOverride = Number(v.toFixed(1));
                }
            }
            // If angle override is set, adjust the previous waypoint position so
            // the segment heading from previous -> current matches the override.
            if (pathPoints[idx] && pathPoints[idx].angleOverride !== undefined) {
                const override = Number(pathPoints[idx].angleOverride);
                const cur = pathPoints[idx];
                const prevIndex = idx - 1;
                // Get prev point (or lastRobotPos if this is the first waypoint)
                const prev = prevIndex >= 0 ? pathPoints[prevIndex] : { x: lastRobotPos.x, y: lastRobotPos.y };

                // Determine how to adjust the previous waypoint.
                // Keep prevPrev fixed. Move prev along the line defined by prevPrev->prev
                // (preserve its bearing) so that the segment prev->cur achieves the
                // desired overridden heading. The second waypoint (cur) remains fixed.
                const wrapAngle = (a) => ((a + 540) % 360) - 180;
                const prevPrev = prevIndex - 1 >= 0 ? pathPoints[prevIndex - 1] : lastRobotPos;

                // Unit vector along prevPrev -> prev (direction to preserve)
                let ux = prev.x - prevPrev.x;
                let uy = prev.y - prevPrev.y;
                let ul = Math.hypot(ux, uy);
                if (ul < 1e-6) {
                    // If length is zero, default to the robot heading direction
                    const baseHeading = prevIndex - 1 >= 0 ? normalizeHeading(parseFloat(document.getElementById('heading-input').value) || 0) : normalizeHeading(parseFloat(document.getElementById('heading-input').value) || 0);
                    const baseRaw = (baseHeading - 90) * (Math.PI / 180);
                    ux = Math.cos(baseRaw); uy = Math.sin(baseRaw); ul = 1;
                } else {
                    ux /= ul; uy /= ul;
                }

                // Desired absolute heading for prev->cur (robot-heading convention)
                let prevHeading = 0;
                if (prevIndex - 1 >= 0) {
                    // compute heading from prevPrev -> prev in robot-heading convention
                    let anglePP = Math.atan2(prev.y - prevPrev.y, prev.x - prevPrev.x) * (180 / Math.PI);
                    anglePP = (anglePP + 360) % 360;
                    const displayAnglePP = ((anglePP - 180 + 360) % 360);
                    prevHeading = wrapAngle(displayAnglePP > 180 ? displayAnglePP - 360 : displayAnglePP + 0);
                } else {
                    prevHeading = normalizeHeading(parseFloat(document.getElementById('heading-input').value) || 0);
                }
                const desiredAbsolute = wrapAngle(prevHeading + override);

                // Unit vector r for desired segment direction (raw atan2 space)
                const rawAngle = (desiredAbsolute - 90) * (Math.PI / 180);
                const rx = Math.cos(rawAngle), ry = Math.sin(rawAngle);

                // Preserve the straight-line distance between prev and cur.
                // Let segLen = |cur - prev|. We want newPrev on the ray prevPrev + t*u
                // (u is unit vector along prevPrev->prev) such that cur - newPrev = segLen * r.
                // Solve t = dot( (cur - prevPrev) - segLen*r, u ).
                const segLen = Math.hypot(cur.x - prev.x, cur.y - prev.y);
                const bx = cur.x - prevPrev.x;
                const by = cur.y - prevPrev.y;
                const t = (bx - segLen * rx) * ux + (by - segLen * ry) * uy; // u is unit
                const newPrevX = prevPrev.x + t * ux;
                const newPrevY = prevPrev.y + t * uy;

                if (prevIndex >= 0) {
                    if (prevIndex >= 1) {
                        pathPoints[prevIndex].x = newPrevX;
                        pathPoints[prevIndex].y = newPrevY;
                    } else {
                        // prev is the first waypoint: move the first waypoint along its ray
                        pathPoints[0].x = newPrevX;
                        pathPoints[0].y = newPrevY;
                    }
                }
            }

            renderWaypoints();
            redrawPath();
            updateDataDisplay();
        }

        function setWaypointSpeed(idx, speedIn) {
            if (!pathPoints[idx]) return;
            pathPoints[idx].speed = Math.max(0.1, parseFloat(speedIn) || 24);
            renderWaypoints();
            updateDataDisplay();
        }

        function reverseWaypoint(idx) {
            if (!pathPoints[idx]) return;
            const waypoint = pathPoints[idx];
            waypoint.reverse = !waypoint.reverse;
            
            // Visually flip the arrow on the robot
            const arrow = document.getElementById('front-arrow');
            if (waypoint.reverse) {
                arrow.classList.add('reversed');
            } else {
                arrow.classList.remove('reversed');
            }
            
            renderWaypoints();
            updateDataDisplay();
        }

        // Update robot visual position, heading, and size from the input fields.
        function updateRobot() {
            const xIn = parseFloat(document.getElementById('x-input-ft').value) || 0;
            const yIn = parseFloat(document.getElementById('y-input-ft').value) || 0;
            const heading = parseFloat(document.getElementById('heading-input').value) || 0;
            const sizeWIn = parseFloat(document.getElementById('size-width-in').value) || 12;
            const sizeHIn = parseFloat(document.getElementById('size-height-in').value) || 12;

            const x = inToPx(xIn);
            const y = inToPx(yIn);

            lastRobotPos = { x, y, heading };

            // Convert to CSS-friendly values and apply
            const cssHeading = (heading + HEADING_ZERO_OFFSET) % 360;
            document.documentElement.style.setProperty('--robot-x', x + 'px');
            document.documentElement.style.setProperty('--robot-y', y + 'px');
            document.documentElement.style.setProperty('--robot-heading', cssHeading + 'deg');

            const sizeW = Math.max(8, sizeWIn) * PX_PER_IN; // ensure sensible min size
            const sizeH = Math.max(8, sizeHIn) * PX_PER_IN;
            document.documentElement.style.setProperty('--square-width', sizeW + 'px');
            document.documentElement.style.setProperty('--square-height', sizeH + 'px');

            // Record history entry
            const entry = { x: xIn, y: yIn, heading, sizeW: sizeWIn, sizeH: sizeHIn };
            robotHistory.push(entry);
            updateDataDisplay();

            // Update debug overlay
            const dbg = document.getElementById('debug-overlay');
            if (dbg) dbg.textContent = `inputHeading: ${heading}\nHEADING_ZERO_OFFSET: ${HEADING_ZERO_OFFSET}\ncssHeading: ${cssHeading.toFixed(2)}`;
        }

        function rotate180() {
            let heading = parseFloat(document.getElementById('heading-input').value) || 0;
            heading = (heading + 180) % 360;
            document.getElementById('heading-input').value = Math.round(heading);
            updateRobot();
        }

        function updateDataDisplay() {
            const hist = robotHistory[robotHistory.length - 1];
            if (!hist) return;
            const sizeLabel = hist.sizeW && hist.sizeH ? `${hist.sizeW} x ${hist.sizeH}` : (hist.size ? `${hist.size} x ${hist.size}` : 'n/a');
            const summary = `Robot: (${hist.x} in, ${hist.y} in) @ ${hist.heading}° | Size: ${sizeLabel} in | Current path: ${pathPoints.length} waypoints | Saved paths: ${savedPaths.length}`;
            const data = {
                currentPath: pathPoints,
                savedPaths
            };
            document.getElementById('data-output').textContent = `${summary}\n${JSON.stringify(data, null, 2)}`;
        }

        function renderWaypoints() {
            waypointOverlay.innerHTML = '';
            if (document.getElementById('show-waypoints').checked) {
                pathPoints.forEach((p, idx) => {
                    const div = document.createElement('div');
                    div.className = 'waypoint';
                    if (highlightedWaypoint === idx) {
                        div.classList.add('highlighted');
                    }
                    div.style.left = p.x + 'px';
                    div.style.top = p.y + 'px';
                    div.dataset.index = idx;
                    div.onmousedown = (e) => startDragWaypoint(e, idx);
                    div.oncontextmenu = (e) => { e.preventDefault(); removeWaypoint(idx); };
                    waypointOverlay.appendChild(div);
                });
            }

            updateWaypointsPanel();
        }

        function highlightWaypoint(idx) {
            highlightedWaypoint = highlightedWaypoint === idx ? null : idx;
            highlightedPath = null;
            renderWaypoints();
            redrawPath();
        }

        function highlightPath(type, index = null) {
            const isSame = highlightedPath && highlightedPath.type === type && highlightedPath.index === index;
            highlightedPath = isSame ? null : { type, index };
            highlightedWaypoint = null;
            renderWaypoints();
            redrawPath();
        }

        function deletePath(type, index = null) {
            if (type === 'saved') {
                savedPaths.splice(index, 1);
            } else {
                pathPoints = [];
            }
            highlightedWaypoint = null;
            highlightedPath = null;
            redrawPath();
            renderWaypoints();
            updateDataDisplay();
        }

        function deleteWaypoint(idx) {
            pathPoints.splice(idx, 1);
            if (highlightedWaypoint === idx) {
                highlightedWaypoint = null;
            } else if (highlightedWaypoint > idx) {
                highlightedWaypoint--;
            }
            redrawPath();
            renderWaypoints();
            updateDataDisplay();
        }

        function updateWaypointsPanel() {
            const container = document.getElementById('paths-container');
            container.innerHTML = '';

            if (savedPaths.length === 0 && pathPoints.length === 0) {
                container.innerHTML = '<div style="color: #888; padding: 10px;">No paths yet. Draw a path to get started.</div>';
                return;
            }

            const segmentLengthIn = (a, b) => (Math.hypot(a.x - b.x, a.y - b.y) / PX_PER_IN).toFixed(2);

            // Saved paths (older paths)
            savedPaths.forEach((path, idx) => {
                const pathSection = document.createElement('div');
                pathSection.className = 'path-section';

                const pathHeader = document.createElement('div');
                pathHeader.className = 'path-header';
                if (highlightedPath && highlightedPath.type === 'saved' && highlightedPath.index === idx) {
                    pathHeader.classList.add('highlighted');
                }
                pathHeader.innerHTML = `
                    <div class="path-header-left">
                        <span class="path-toggle">▶</span>
                        <span class="path-title">Path ${idx + 1} (${path.points.length} waypoints)</span>
                    </div>
                    <div class="path-header-controls">
                        <button onclick="event.stopPropagation(); highlightPath('saved', ${idx});">Highlight</button>
                        <button class="delete" onclick="event.stopPropagation(); deletePath('saved', ${idx});">Delete</button>
                    </div>
                `;

                const pathContent = document.createElement('div');
                pathContent.className = 'path-content';
                const summary = document.createElement('div');
                summary.style.padding = '10px';
                const startIn = path.start ? { x: pxToIn(path.start.x), y: pxToIn(path.start.y) } : null;
                let totalLen = 0;
                if (path.points.length > 0) {
                    let prev = path.start || lastRobotPos;
                    path.points.forEach(pt => {
                        totalLen += parseFloat(segmentLengthIn(pt, prev));
                        prev = pt;
                    });
                }
                summary.innerHTML = `Waypoints: ${path.points.length}`
                    + (startIn ? `<br>Start: (${startIn.x} in, ${startIn.y} in)` : '')
                    + `<br>Total length: ${totalLen.toFixed(2)} in`;
                pathContent.appendChild(summary);

                pathSection.appendChild(pathHeader);
                pathSection.appendChild(pathContent);
                container.appendChild(pathSection);

                pathHeader.onclick = () => {
                    const toggle = pathHeader.querySelector('.path-toggle');
                    toggle.classList.toggle('expanded');
                    pathContent.classList.toggle('expanded');
                };
            });

            // Current path (editable)
            const currentSection = document.createElement('div');
            currentSection.className = 'path-section';

            const currentHeader = document.createElement('div');
            currentHeader.className = 'path-header';
            if (highlightedPath && highlightedPath.type === 'current') {
                currentHeader.classList.add('highlighted');
            }
            currentHeader.innerHTML = `
                <div class="path-header-left">
                    <span class="path-toggle expanded">▶</span>
                    <div style="display: flex; gap: 4px; align-items: center;">
                        <span class="path-title">Current Path (${pathPoints.length} waypoints)</span>
                        <button class="secondary" onclick="toggleWaypointsPanel()" title="Toggle Waypoints Panel">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-list-ul" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M5.5 3.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 4a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 4a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>
                                <path fill-rule="evenodd" d="M1.5 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5zm0 4a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5zm0 4a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="path-header-controls">
                    <button onclick="event.stopPropagation(); highlightPath('current');">Highlight</button>
                    <button class="delete" onclick="event.stopPropagation(); deletePath('current');">Delete</button>
                </div>
            `;

            const currentContent = document.createElement('div');
            currentContent.className = 'path-content expanded';

            const waypointsList = document.createElement('div');
            waypointsList.id = 'waypoints-list';

            if (pathPoints.length === 0) {
                const empty = document.createElement('div');
                empty.style.padding = '10px';
                empty.style.color = '#888';
                empty.textContent = 'No waypoints yet.';
                waypointsList.appendChild(empty);
            }

            let runningLen = 0;
            let runningIMULen = 0;
            // IMU offset (inches) used when computing arc distances for IMU-based travel
            const imuOffset = parseFloat(document.getElementById('imu-offset').value) || 0;
            // Robot input heading is treated as the zero-reference for displayed angles
            const robotHeading = normalizeHeading(parseFloat(document.getElementById('heading-input').value) || 0);
            // Track previous segment heading for relative-turn calculations; initialize to robot heading
            let prevHeading = robotHeading;
            let prevHeadingForImu = robotHeading; // Track heading for IMU arc calculation
            // Helper: wrap angles into [-180, 180]
            const wrapAngle = (a) => ((a + 540) % 360) - 180;
            pathPoints.forEach((p, idx) => {
                const prev = idx === 0 ? lastRobotPos : pathPoints[idx - 1];
                const dx = p.x - prev.x;
                const dy = p.y - prev.y;
                let angle = Math.atan2(dy, dx) * (180 / Math.PI);
                angle = (angle + 360) % 360;
                const displayAngle = ((angle - 180 + 360) % 360);
                const normalizedAngle = displayAngle > 180 ? displayAngle - 360 : displayAngle;
                // Shift by +90° to align the segment direction with the robot-heading convention
                const headingAdjusted = wrapAngle(normalizedAngle + 90);
                // Determine absolute segment heading (allow per-waypoint override)
                let absoluteHeading = headingAdjusted;
                if (p.angleOverride !== undefined) {
                    absoluteHeading = wrapAngle(prevHeading + Number(p.angleOverride));
                }

                // Relative turn from the previous segment heading
                const relativeAngle = wrapAngle(absoluteHeading - prevHeading);

                // Use the exact relative angle (no thresholds). Display precise
                // values to one decimal place elsewhere.
                let angleForDisplay = relativeAngle;
                // Update previous-heading tracker to the absolute heading we used
                prevHeading = absoluteHeading;
                const segLen = parseFloat(segmentLengthIn(p, prev));

                // Calculate IMU distance (accounts for arc during turns)
                const currentHeadingForImu = absoluteHeading;
                let turnAngle = ((currentHeadingForImu - prevHeadingForImu + 540) % 360) - 180;
                const turnRad = turnAngle * (Math.PI / 180);
                const arcDistance = Math.abs(imuOffset * turnRad);
                const segIMULen = segLen + arcDistance;
                runningIMULen += segIMULen;
                prevHeadingForImu = currentHeadingForImu;

                // If waypoint angle is overridden, account for IMU arc distance
                // so the displayed segment length reflects the traveled distance.
                const segDisplayLen = (p.angleOverride !== undefined) ? segIMULen : segLen;
                runningLen += segDisplayLen;

                const item = document.createElement('div');
                item.className = 'waypoint-item';
                if (highlightedWaypoint === idx) {
                    item.classList.add('highlighted');
                }
                const delay = (p.delay || 0) / 1000; // Convert ms back to seconds for display
                const speed = p.speed || 24;
                const isReversed = p.reverse || false;
                const imuDistInfo = imuOffset !== 0 ? `<div style="color: rgba(255, 174, 94, 0.9); font-size: 10px;">IMU dist: ${segIMULen.toFixed(2)} in | Total IMU: ${runningIMULen.toFixed(2)} in</div>` : '';
                // Prepare angle display with exact one-decimal formatting and
                // normalize negative-zero to positive zero so UI shows `0.0`.
                const rawAngleValue = angleForDisplay;
                let angleDisplayNum = Number(rawAngleValue);
                angleDisplayNum = Number(angleDisplayNum.toFixed(1));
                if (Object.is(angleDisplayNum, -0)) angleDisplayNum = 0;
                // If this waypoint has an explicit angle override (relative turn), show that instead
                if (p.angleOverride !== undefined) {
                    angleDisplayNum = Number(p.angleOverride.toFixed(1));
                }
                const angleDisplayStr = angleDisplayNum.toFixed(1);

                item.innerHTML = `
                    <div class="waypoint-item-number">#${idx + 1}${isReversed ? ' ⬅' : ''}</div>
                    <div>Segment: ${segDisplayLen.toFixed(2)} in${p.angleOverride !== undefined ? ' (adjusted)' : ''}</div>
                    <div>Total to here: ${runningLen.toFixed(2)} in</div>
                    ${imuDistInfo}
                    <div class="waypoint-item-angle">
                        ${isReversed ? '⬅' : '→'} Angle:
                        <input type="number" value="${angleDisplayStr}" min="-180" max="180" step="0.1" onchange="setWaypointAngle(${idx}, this.value)" style="width:72px; margin-left:6px;">
                        ${isReversed ? ' (reversed)' : ''}
                        ${p.angleOverride !== undefined ? '<span style="color: rgba(255,174,94,0.9); margin-left:8px; font-size:10px;">(overridden)</span>' : ''}
                    </div>
                    <div class="delay-input-container">
                        <label>Speed (in/s):</label>
                        <input type="number" value="${speed}" min="0.1" step="0.5" onchange="setWaypointSpeed(${idx}, this.value)">
                    </div>
                    <div class="delay-input-container">
                        <label>Delay (sec):</label>
                        <input type="number" value="${delay.toFixed(1)}" min="0" step="0.1" onchange="setWaypointDelay(${idx}, this.value)">
                    </div>
                    <div class="waypoint-item-controls">
                        <button onclick="highlightWaypoint(${idx})">Highlight</button>
                        <button onclick="reverseWaypoint(${idx})" title="Drive backwards to this waypoint">${isReversed ? 'Forward' : 'Reverse'}</button>
                        <button class="delete" onclick="deleteWaypoint(${idx})">Delete</button>
                    </div>
                `;
                waypointsList.appendChild(item);
            });

            currentContent.appendChild(waypointsList);
            currentSection.appendChild(currentHeader);
            currentSection.appendChild(currentContent);
            container.appendChild(currentSection);

            currentHeader.onclick = () => {
                const toggle = currentHeader.querySelector('.path-toggle');
                toggle.classList.toggle('expanded');
                currentContent.classList.toggle('expanded');
            };
        }

        function toggleWaypointsPanel() {
            document.getElementById('waypoints-panel').classList.toggle('open');
        }

        function startDragWaypoint(e, idx) {
            draggingWaypoint = idx;
            const waypoint = e.target;
            waypoint.classList.add('dragging');
            e.stopPropagation();
        }

        function removeWaypoint(idx) {
            pathPoints.splice(idx, 1);
            redrawPath();
            renderWaypoints();
            updateDataDisplay();
        }

        function redrawPath() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const drawSegments = (startPoint, points, meta) => {
                if (!points || points.length === 0) return;
                ctx.lineWidth = 3;
                const highlightColor = 'rgba(255, 200, 0, 1)';
                const baseColor = meta.type === 'saved' ? 'rgba(100, 200, 255, 0.5)' : 'rgba(100, 200, 255, 0.9)';
                const isHighlightedPath = highlightedPath && highlightedPath.type === meta.type && highlightedPath.index === meta.index;

                const getStrokeColor = (idx) => {
                    if (meta.type === 'current' && highlightedWaypoint === idx) return highlightColor;
                    if (isHighlightedPath) return highlightColor;
                    return baseColor;
                };

                ctx.strokeStyle = getStrokeColor(0);
                ctx.beginPath();
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();

                for (let i = 1; i < points.length; i++) {
                    ctx.strokeStyle = getStrokeColor(i);
                    ctx.beginPath();
                    ctx.moveTo(points[i - 1].x, points[i - 1].y);
                    ctx.lineTo(points[i].x, points[i].y);
                    ctx.stroke();
                }
            };

            // Draw saved paths first
            savedPaths.forEach((path, idx) => {
                const start = path.start || lastRobotPos;
                drawSegments(start, path.points, { type: 'saved', index: idx });
            });

            // Draw current path on top
            drawSegments(lastRobotPos, pathPoints, { type: 'current', index: null });
        }

        function toggleDrawMode() {
            isDrawingPath = !isDrawingPath;
            const btn = document.getElementById('draw-btn');
            canvas.style.pointerEvents = isDrawingPath ? 'auto' : 'none';
            canvas.style.cursor = isDrawingPath ? 'crosshair' : 'default';
            btn.textContent = isDrawingPath ? 'Stop Drawing' : 'Draw Path';
            btn.style.background = isDrawingPath ? '#00aa00' : '#0066cc';
            // Drawing always starts from robot: ensure panel reflects robot->first segment
            renderWaypoints();
            redrawPath();
        }

        function clearPath() {
            // Clear current path and reset any highlights
            pathPoints = [];
            highlightedWaypoint = null;
            if (highlightedPath && highlightedPath.type === 'current') {
                highlightedPath = null;
            }

            // Reset robot position to the input-defined start position
            const xIn = parseFloat(document.getElementById('x-input-ft').value) || 0;
            const yIn = parseFloat(document.getElementById('y-input-ft').value) || 0;
            const heading = parseFloat(document.getElementById('heading-input').value) || 0;
            lastRobotPos = { x: inToPx(xIn), y: inToPx(yIn), heading };

            // Also reset any running playback/timer when clearing the current path
            if (typeof resetRun === 'function') resetRun();
            redrawPath();
            renderWaypoints();
            updateDataDisplay();
        }

        function newPath() {
            if (pathPoints.length > 0) {
                savedPaths.push({ start: { x: lastRobotPos.x, y: lastRobotPos.y }, points: [...pathPoints] });
                // Continue from where the previous path ended
                const lastPoint = pathPoints[pathPoints.length - 1];
                lastRobotPos = { x: lastPoint.x, y: lastPoint.y, heading: lastRobotPos.heading };
                // Update input fields to match
                document.getElementById('x-input-ft').value = pxToIn(lastPoint.x);
                document.getElementById('y-input-ft').value = pxToIn(lastPoint.y);
                updateRobot();
            }
            pathPoints = [];
            highlightedWaypoint = null;
            highlightedPath = null;
            redrawPath();
            renderWaypoints();
            updateDataDisplay();
        }

        function generateCppCode() {
            if (pathPoints.length === 0 && savedPaths.length === 0) {
                alert('No paths to generate code from. Draw a path first!');
                return;
            }

            let code = '// Generated VEX C++ code for skillsAuton()\n';
            code += '// Copy and paste this into your skillsAuton() function\n\n';
            
            const robotStartX = parseFloat(document.getElementById('x-input-ft').value);
            const robotStartY = parseFloat(document.getElementById('y-input-ft').value);
            const robotStartHeading = parseFloat(document.getElementById('heading-input').value);
            const imuOffset = parseFloat(document.getElementById('imu-offset').value) || 0;
            const xOffset = getXOffset();
            const yOffset = getYOffset();
            
            code += `// Starting position: (${robotStartX.toFixed(2)}", ${robotStartY.toFixed(2)}") @ ${robotStartHeading.toFixed(0)}°\n`;
            code += `// IMU offset from center: ${imuOffset.toFixed(2)}" ${imuOffset > 0 ? '(forward)' : imuOffset < 0 ? '(backward)' : '(centered)'}\n`;
            code += `// Calibration offsets: X=${xOffset.toFixed(2)}", Y=${yOffset.toFixed(2)}"\n`;
            code += `calibrateIMU();\n`;
            code += `resetEncoders();\n`;
            code += `odometry.reset();\n`;
            code += `drivePID.reset();\n`;
            code += `turnPID.reset();\n\n`;

            // Function to generate code for a path
            const generatePathCode = (points, startPos, pathIndex) => {
                let pathCode = `// Path ${pathIndex + 1}\n`;
                let currentPos = startPos;
                // Heading input is the zero reference point
                let currentHeading = normalizeHeading(robotStartHeading);
                let currentHeadingForImu = normalizeHeading(robotStartHeading); // Track for IMU arc calculation

                for (let i = 0; i < points.length; i++) {
                    const target = points[i];
                    const targetX = pxToIn(target.x) - xOffset;
                    const targetY = pxToIn(target.y) - yOffset;
                    
                    // Calculate distance and angle from current position to target
                    const dx = target.x - currentPos.x;
                    const dy = target.y - currentPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) / PX_PER_IN;

                    // Heading (+90 shift) relative to robot input heading
                    // If the waypoint has an explicit relative-angle override, use that
                    let targetHeading;
                    if (typeof target.angleOverride === 'number') {
                        // target.angleOverride is a relative turn from the previous heading
                        targetHeading = normalizeHeading(currentHeading + target.angleOverride);
                    } else {
                        targetHeading = Math.atan2(dy, dx) * (180 / Math.PI);
                        targetHeading = ((targetHeading + 90 + 360) % 360);
                        if (targetHeading > 180) targetHeading -= 360;
                    }

                    // Raw heading (no +90) to match UI IMU distance calc
                    const headingRaw = normalizeHeading(Math.atan2(dy, dx) * (180 / Math.PI));

                    // Calculate turn needed (robot heading is the zero reference).
                    // Keep the exact turnAngle (no threshold overrides).
                    let turnAngle = currentHeading - targetHeading;
                    if (turnAngle > 180) turnAngle -= 360;
                    if (turnAngle < -180) turnAngle += 360;

                    // Calculate IMU distance using heading delta (matches UI calculation)
                    const targetHeadingForImu = targetHeading;
                    let imuTurnAngle = targetHeadingForImu - currentHeadingForImu;
                    if (imuTurnAngle > 180) imuTurnAngle -= 360;
                    if (imuTurnAngle < -180) imuTurnAngle += 360;
                    const turnRadIMU = imuTurnAngle * (Math.PI / 180);
                    const arcDistance = Math.abs(imuOffset * turnRadIMU);
                    const imuDistanceCalc = distance + arcDistance;
                    const imuDistNote = imuOffset !== 0 ? ` (IMU: ${imuDistanceCalc.toFixed(2)}")` : '';
                    
                    pathCode += `// Waypoint ${i + 1}: (${targetX}", ${targetY}") - Distance: ${distance.toFixed(2)}"${imuDistNote}\n`;
                    
                    // Update heading tracker
                    currentHeadingForImu = targetHeadingForImu;
                    
                    // Check if waypoint is reversed (drive backwards)
                    const isReversed = target.reverse || false;
                    
                    // Only turn if angle is significant and NOT reversed
                    // When not reversed, emit a turn command using the exact computed
                    // turnAngle. Do not apply any thresholds here — caller requested
                    // precise angles. Small turns will be output with one decimal.
                    if (!isReversed) {
                        let commandedTurn = -turnAngle;
                        if (commandedTurn > 180) commandedTurn -= 360;
                        if (commandedTurn < -180) commandedTurn += 360;
                        let cmdTurnNum = Number(commandedTurn.toFixed(1));
                        if (Object.is(cmdTurnNum, -0)) cmdTurnNum = 0;
                        pathCode += `turnWithPID(${cmdTurnNum.toFixed(1)});\n`;
                        currentHeading = targetHeading;
                    }
                    
                    // Drive to waypoint using IMU-adjusted distance (negative distance for reverse - drives backwards)
                    if (distance > 0.5 || arcDistance > 0.5) {
                        const driveCmd = isReversed ? '-' : '';
                        if (imuOffset !== 0 && arcDistance > 0.01) {
                            pathCode += `driveWithPID(${driveCmd}${distance.toFixed(2)} + IMU_distance);\n`;
                        } else {
                            pathCode += `driveWithPID(${driveCmd}${distance.toFixed(2)});\n`;
                        }
                    }
                    
                    // Add delay if set
                    const delay = target.delay || 0;
                    if (delay > 0) {
                        pathCode += `wait(${delay}, msec);\n`;
                    }
                    
                    // Add intake/output control if needed (you can customize this)
                    // pathCode += `// intakeMotor.spin(forward);\n`;
                    // pathCode += `// wait(500, msec);\n`;
                    
                    pathCode += `updateOdometry();\n\n`;
                    
                    currentPos = target;
                }
                
                return pathCode;
            };

            // Generate code for saved paths
            savedPaths.forEach((path, idx) => {
                const startPos = path.start || { x: inToPx(robotStartX), y: inToPx(robotStartY) };
                code += generatePathCode(path.points, startPos, idx);
            });

            // Generate code for current path
            if (pathPoints.length > 0) {
                const startPos = { x: inToPx(robotStartX), y: inToPx(robotStartY) };
                code += generatePathCode(pathPoints, startPos, savedPaths.length);
            }

            code += `Controller1.rumble(".−");\n`;
            code += `// End of generated code\n`;

            // Display code in modal
            openCodeModal(code);
        }

        function getCurrentStateData() {
            const imuOffset = parseFloat(document.getElementById('imu-offset').value) || 0;
            const xOffset = getXOffset();
            const yOffset = getYOffset();
            return {
                field: { width: 144, height: 144, unit: 'inches', pxPerIn: PX_PER_IN, pxPerFt: PX_PER_FT },
                imuOffset: imuOffset,
                xOffset: xOffset,
                yOffset: yOffset,
                robotHistory: robotHistory.map(r => ({
                    x: r.x,
                    y: r.y,
                    heading: r.heading,
                    sizeW: r.sizeW ?? r.size,
                    sizeH: r.sizeH ?? r.size
                })),
                currentPathInches: pathPoints.map(p => ({ x: pxToIn(p.x), y: pxToIn(p.y), delay: p.delay || 0, reverse: p.reverse || false })),
                savedPathsInches: savedPaths.map(p => ({
                    start: p.start ? { x: pxToIn(p.start.x), y: pxToIn(p.start.y) } : null,
                    points: p.points.map(pt => ({ x: pxToIn(pt.x), y: pxToIn(pt.y), delay: pt.delay || 0, reverse: pt.reverse || false }))
                })),
                // Legacy keys
                pathWaypointsInches: pathPoints.map(p => ({ x: pxToIn(p.x), y: pxToIn(p.y) })),
                pathWaypoints: pathPoints.map(p => ({ x: pxToIn(p.x), y: pxToIn(p.y) }))
            };
        }

        function exportData() {
            const data = getCurrentStateData();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'robot-path.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function applyDataObject(data, { showAlert = true } = {}) {
            // Clear existing state first
            pathPoints = [];
            savedPaths = [];
            highlightedWaypoint = null;
            highlightedPath = null;
            robotHistory = Array.isArray(data.robotHistory) ? data.robotHistory : [];

            const unit = (data.field && data.field.unit) ? data.field.unit.toLowerCase() : 'feet';
            const toPx = (val) => unit === 'feet' ? ftToPx(parseFloat(val)) : inToPx(parseFloat(val));

            // Load saved paths if present
            if (Array.isArray(data.savedPathsInches)) {
                savedPaths = data.savedPathsInches.map(p => ({
                    start: p.start ? { x: toPx(p.start.x), y: toPx(p.start.y) } : null,
                    points: (p.points || []).map(pt => ({ x: toPx(pt.x), y: toPx(pt.y), delay: pt.delay || 0, reverse: pt.reverse || pt.flip || false }))
                }));
            } else if (Array.isArray(data.savedPaths)) {
                savedPaths = data.savedPaths.map(p => ({
                    start: p.start ? { x: toPx(p.start.x), y: toPx(p.start.y) } : null,
                    points: (p.points || []).map(pt => ({ x: toPx(pt.x), y: toPx(pt.y), delay: pt.delay || 0, reverse: pt.reverse || pt.flip || false }))
                }));
            }

            // Load current path (new key) or legacy pathWaypoints
            if (Array.isArray(data.currentPathInches)) {
                pathPoints = data.currentPathInches.map(p => ({ x: toPx(p.x), y: toPx(p.y), delay: p.delay || 0, reverse: p.reverse || p.flip || false }));
            } else if (Array.isArray(data.currentPath)) {
                pathPoints = data.currentPath.map(p => ({ x: toPx(p.x), y: toPx(p.y), delay: p.delay || 0, reverse: p.reverse || p.flip || false }));
            } else if (Array.isArray(data.pathWaypointsInches)) {
                pathPoints = data.pathWaypointsInches.map(p => ({ x: toPx(p.x), y: toPx(p.y), delay: p.delay || 0, reverse: p.reverse || p.flip || false }));
            } else if (Array.isArray(data.pathWaypoints)) {
                pathPoints = data.pathWaypoints.map(p => ({ x: toPx(p.x), y: toPx(p.y), delay: p.delay || 0, reverse: p.reverse || p.flip || false }));
            }

            // Load IMU and calibration offsets if available
            if (data.imuOffset !== undefined) {
                document.getElementById('imu-offset').value = data.imuOffset;
            }
            if (data.xOffset !== undefined) {
                xOffsetCal = data.xOffset;
            }
            if (data.yOffset !== undefined) {
                yOffsetCal = data.yOffset;
            }

            // Load last robot position if available
            if (data.robotHistory && data.robotHistory.length > 0) {
                const convertLen = (val) => unit === 'feet' ? parseFloat(val) * 12 : parseFloat(val);
                robotHistory = data.robotHistory.map(r => ({
                    x: convertLen(r.x),
                    y: convertLen(r.y),
                    heading: r.heading,
                    sizeW: r.sizeW ? convertLen(r.sizeW) : (r.size ? convertLen(r.size) : null),
                    sizeH: r.sizeH ? convertLen(r.sizeH) : (r.size ? convertLen(r.size) : null)
                }));
                const lastRobot = robotHistory[robotHistory.length - 1];
                document.getElementById('x-input-ft').value = lastRobot.x;
                document.getElementById('y-input-ft').value = lastRobot.y;
                document.getElementById('heading-input').value = lastRobot.heading;
                document.getElementById('size-width-in').value = lastRobot.sizeW ?? lastRobot.size ?? 12;
                document.getElementById('size-height-in').value = lastRobot.sizeH ?? lastRobot.size ?? 12;
                updateRobot();
            }

            // Ensure waypoints checkbox is checked to show them
            document.getElementById('show-waypoints').checked = true;

            // Redraw everything
            redrawPath();
            renderWaypoints();
            updateDataDisplay();

            if (showAlert) {
                alert(`Data loaded!\nCurrent path: ${pathPoints.length} waypoints\nSaved paths: ${savedPaths.length}`);
            }
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    applyDataObject(data, { showAlert: true });
                } catch (error) {
                    alert('Error importing file: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input so same file can be uploaded again
            event.target.value = '';
        }

        // Preset management (stored in localStorage)
        const PRESET_STORAGE_KEY = 'vex-path-presets';

        function refreshPresetSelect() {
            const select = document.getElementById('preset-select');
            if (!select) return;
            const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || '{}');
            select.innerHTML = '<option value="">Select preset</option>';
            Object.keys(presets).sort().forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                select.appendChild(opt);
            });
        }

        function savePreset() {
            const nameInput = document.getElementById('preset-name');
            const select = document.getElementById('preset-select');
            const name = (nameInput.value || select.value || '').trim();
            if (!name) {
                alert('Enter a preset name first.');
                return;
            }
            const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || '{}');
            presets[name] = getCurrentStateData();
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
            refreshPresetSelect();
            select.value = name;
            alert(`Preset "${name}" saved.`);
        }

        function loadPreset() {
            const nameInput = document.getElementById('preset-name');
            const select = document.getElementById('preset-select');
            const name = (select.value || nameInput.value || '').trim();
            if (!name) {
                alert('Select or enter a preset name.');
                return;
            }
            const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || '{}');
            const data = presets[name];
            if (!data) {
                alert(`Preset "${name}" not found.`);
                return;
            }
            applyDataObject(data, { showAlert: false });
            alert(`Preset "${name}" loaded.`);
        }

        function deletePreset() {
            const nameInput = document.getElementById('preset-name');
            const select = document.getElementById('preset-select');
            const name = (select.value || nameInput.value || '').trim();
            if (!name) {
                alert('Select a preset to delete.');
                return;
            }
            const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY) || '{}');
            if (!presets[name]) {
                alert(`Preset "${name}" not found.`);
                return;
            }
            delete presets[name];
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
            refreshPresetSelect();
            select.value = '';
            alert(`Preset "${name}" deleted.`);
        }

        // Populate presets on load
        window.addEventListener('load', refreshPresetSelect);

        // Drag to draw path (straight lines, starting from robot)
        canvas.addEventListener('mousedown', (e) => {
            if (!isDrawingPath) return;
            const rect = field.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (x >= 0 && x <= 600 && y >= 0 && y <= 600) {
                pathPoints.push({ x, y });
                redrawPath();
                renderWaypoints();
                updateDataDisplay();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawingPath || e.buttons === 0) return;
            const rect = field.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (x >= 0 && x <= 600 && y >= 0 && y <= 600) {
                const lastPoint = pathPoints[pathPoints.length - 1];
                if (Math.hypot(x - lastPoint.x, y - lastPoint.y) > 8) {
                    pathPoints.push({ x, y });
                    redrawPath();
                    renderWaypoints();
                }
            }
        });

        // Drag waypoints
        document.addEventListener('mousemove', (e) => {
            if (draggingWaypoint !== null) {
                const rect = field.getBoundingClientRect();
                let x = e.clientX - rect.left;
                let y = e.clientY - rect.top;
                x = Math.max(0, Math.min(600, x));
                y = Math.max(0, Math.min(600, y));
                
                pathPoints[draggingWaypoint] = { x, y };
                redrawPath();
                renderWaypoints();
                updateDataDisplay();
            }
        });

        document.addEventListener('mouseup', () => {
            if (draggingWaypoint !== null) {
                document.querySelectorAll('.waypoint.dragging').forEach(w => w.classList.remove('dragging'));
                draggingWaypoint = null;
            }
        });

        // Playback: run robot along the path at constant speed
        let runRAF = null;
        let isRunning = false;
        let currentSegment = 0;
        let segmentStart = null;
        let segmentEnd = null;
        let progress = 0; // 0..1 along segment
        let speedPxPerS = 100; // default: 2 ft/s -> 100 px/s
        let delayEndTime = null; // for waypoint delays
        let waypointReachedTime = null; // track when waypoint was reached
        let timerStartTime = null; // for match/skills timer
        let timerMaxSeconds = 60; // default to skills (60 seconds)
        let runPrevHeading = null; // heading (degrees) tracked during run playback (normalized)

        function updateTimerDisplay() {
            const timerDisplay = document.getElementById('timer-display');
            if (!timerStartTime || !isRunning) return;
            
            const elapsedMs = performance.now() - timerStartTime;
            const elapsedSec = Math.max(0, timerMaxSeconds - elapsedMs / 1000);
            const minutes = Math.floor(elapsedSec / 60);
            const seconds = Math.floor(elapsedSec % 60);
            const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            timerDisplay.textContent = timeStr;
            
            // Change color based on time remaining
            if (elapsedSec <= 0) {
                timerDisplay.style.color = 'var(--danger)';
                timerDisplay.style.background = 'rgba(241, 91, 91, 0.1)';
                timerDisplay.style.borderColor = 'var(--danger)';
                isRunning = false;
                pauseRun();
            } else if (elapsedSec <= 10) {
                timerDisplay.style.color = '#ff9800';
                timerDisplay.style.background = 'rgba(255, 152, 0, 0.1)';
                timerDisplay.style.borderColor = '#ff9800';
            } else {
                timerDisplay.style.color = 'var(--text)';
                timerDisplay.style.background = 'var(--card)';
                timerDisplay.style.borderColor = 'var(--border)';
            }
        }

        function startRun() {
            if (pathPoints.length === 0) return;
            const speedIn = parseFloat(document.getElementById('speed-input-ft').value) || 24;
            speedPxPerS = speedIn * PX_PER_IN;
            isRunning = true;
            currentSegment = 0;
            // Start from current robot position (from input values)
            const xIn = parseFloat(document.getElementById('x-input-ft').value);
            const yIn = parseFloat(document.getElementById('y-input-ft').value);
            segmentStart = { x: inToPx(xIn), y: inToPx(yIn) };
            segmentEnd = { x: pathPoints[0].x, y: pathPoints[0].y };
            progress = 0;
            
            // Set timer based on field mode
            timerMaxSeconds = fieldMode === 'match' ? 15 : 60;
            timerStartTime = performance.now();
            const timerDisplay = document.getElementById('timer-display');
            timerDisplay.style.display = 'block';
            timerDisplay.style.color = 'var(--text)';
            timerDisplay.style.background = 'var(--card)';
            timerDisplay.style.borderColor = 'var(--border)';
            
            // Initialize previous-heading tracking for run playback comparisons
            runPrevHeading = normalizeHeading(parseFloat(document.getElementById('heading-input').value) || 0);
            runStep(performance.now());
        }

        function pauseRun() {
            isRunning = false;
            if (runRAF) cancelAnimationFrame(runRAF);
            runRAF = null;
        }

        function resetRun() {
            pauseRun();
            waypointReachedTime = null;
            timerStartTime = null;
            // Remove reversed class from arrow
            const arrow = document.getElementById('front-arrow');
            arrow.classList.remove('reversed');
            // Reset timer display
            const timerDisplay = document.getElementById('timer-display');
            timerDisplay.style.display = 'none';
            // Reset robot to inputs
            updateRobot();
        }

        function runStep(prevTs) {
            runRAF = requestAnimationFrame((ts) => {
                if (!isRunning) return;
                
                // Handle waypoint delay
                if (waypointReachedTime !== null) {
                    const elapsedDelay = ts - waypointReachedTime;
                    const waypoint = pathPoints[currentSegment];
                    const delay = waypoint.delay || 0;
                    
                    if (elapsedDelay < delay) {
                        // Still waiting at waypoint
                        updateTimerDisplay(); // Keep timer running during delay
                        runStep(prevTs);
                        return;
                    } else {
                        // Delay finished, move to next segment
                        waypointReachedTime = null;
                        currentSegment += 1;
                        if (currentSegment >= pathPoints.length) {
                            isRunning = false;
                            return;
                        }
                        segmentStart = pathPoints[currentSegment - 1];
                        segmentEnd = { x: pathPoints[currentSegment].x, y: pathPoints[currentSegment].y };
                        progress = 0;
                        prevTs = ts; // Update timestamp to prevent jump
                    }
                }
                
                const dt = (ts - prevTs) / 1000; // seconds
                prevTs = ts;
                const dx = segmentEnd.x - segmentStart.x;
                const dy = segmentEnd.y - segmentStart.y;
                const segLen = Math.hypot(dx, dy);
                
                // Use waypoint-specific speed if available, otherwise use default
                const waypoint = pathPoints[currentSegment];
                const waypointSpeed = waypoint && waypoint.speed ? waypoint.speed : 24; // default 24 in/s
                const segmentSpeedPxPerS = waypointSpeed * PX_PER_IN;
                const isReversed = waypoint && waypoint.reverse;
                
                const advance = (segmentSpeedPxPerS * dt) / segLen;
                progress = Math.min(1, progress + advance);
                const cx = segmentStart.x + dx * progress;
                const cy = segmentStart.y + dy * progress;
                // Compute the segment's heading and convert it to the same
                // normalized representation we use elsewhere ([-180,180]).
                let rawAngle = Math.atan2(dy, dx) * (180 / Math.PI);
                rawAngle = (rawAngle + 360) % 360;
                const displayAngle = ((rawAngle - 180 + 360) % 360);
                const normalizedAngle = displayAngle > 180 ? displayAngle - 360 : displayAngle;
                // Align with robot heading convention (+90 shift) and wrap to [-180,180]
                const wrapAngle = (a) => ((a + 540) % 360) - 180;
                const headingAdjusted = wrapAngle(normalizedAngle + 90);

                // Determine if the heading is effectively unchanged from the previous
                // segment AND if it equals the robot's input heading. If so, treat
                // the displayed/run angle as 0 (no turn) to avoid confusing repeated values.
                // Use the exact segment heading for playback (no thresholds).
                const robotHeadingNormalized = normalizeHeading(parseFloat(document.getElementById('heading-input').value) || 0);
                let headingForRun = headingAdjusted;

                // Convert headingForRun back to the CSS rotation space using the same
                // HEADING_ZERO_OFFSET used by `updateRobot()` (visual rotation offset).
                // Map the run-playback heading into CSS rotation space.
                const cssHeading = (headingForRun + HEADING_ZERO_OFFSET) % 360;

                document.documentElement.style.setProperty('--robot-x', cx + 'px');
                document.documentElement.style.setProperty('--robot-y', cy + 'px');
                document.documentElement.style.setProperty('--robot-heading', cssHeading + 'deg');
                // Update debug overlay while running
                const dbg = document.getElementById('debug-overlay');
                if (dbg) dbg.textContent = `run frame:\nheadingAdjusted: ${headingAdjusted.toFixed(2)}\nheadingForRun: ${headingForRun.toFixed(2)}\nrunPrevHeading: ${runPrevHeading?.toFixed(2)}\ncssHeading: ${cssHeading.toFixed(2)}`;

                // Track the previous heading for the next frame's comparisons
                runPrevHeading = headingAdjusted;
                
                // Update timer display
                updateTimerDisplay();
                
                // Flip arrow for reversed waypoints
                const arrow = document.getElementById('front-arrow');
                if (isReversed) {
                    arrow.classList.add('reversed');
                } else {
                    arrow.classList.remove('reversed');
                }

                if (progress >= 1) {
                    // Reached waypoint, check for delay
                    const waypoint = pathPoints[currentSegment];
                    const delay = waypoint.delay || 0;
                    
                    if (delay > 0) {
                        // Start delay at this waypoint
                        waypointReachedTime = ts;
                        runStep(prevTs);
                        return;
                    }
                    
                    // Move to next segment
                    currentSegment += 1;
                    if (currentSegment >= pathPoints.length) {
                        // Finished
                        isRunning = false;
                        return;
                    } else {
                        segmentStart = { x: cx, y: cy };
                        segmentEnd = { x: pathPoints[currentSegment].x, y: pathPoints[currentSegment].y };
                        progress = 0;
                    }
                }

                runStep(prevTs);
            });
        }

        // Arrow rotation
        document.getElementById('front-arrow').addEventListener('mousedown', (e) => {
            arrowDragging = true;
            e.stopPropagation();
        });

        document.addEventListener('mousemove', (e) => {
            if (arrowDragging) {
                const fieldRect = field.getBoundingClientRect();
                const robotElement = document.querySelector('.robot');
                const robotRect = robotElement.getBoundingClientRect();
                const centerX = robotRect.left + robotRect.width / 2;
                const centerY = robotRect.top + robotRect.height / 2;

                const dx = e.clientX - centerX;
                const dy = e.clientY - centerY;
                let absAngle = Math.atan2(dy, dx) * (180 / Math.PI);
                absAngle = (absAngle + 360) % 360;
                const inputHeading = (absAngle - HEADING_ZERO_OFFSET + 360) % 360;

                document.getElementById('heading-input').value = Math.round(inputHeading);
                updateRobot();
            }
        });

        document.addEventListener('mouseup', () => {
            arrowDragging = false;
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            const step = 0.25;
            let xFt = parseFloat(document.getElementById('x-input-ft').value);
            let yFt = parseFloat(document.getElementById('y-input-ft').value);
            let heading = parseFloat(document.getElementById('heading-input').value);

            switch(e.key) {
                case 'ArrowUp': yFt = Math.max(0, yFt - step); e.preventDefault(); break;
                case 'ArrowDown': yFt = Math.min(12, yFt + step); e.preventDefault(); break;
                case 'ArrowLeft': xFt = Math.max(0, xFt - step); e.preventDefault(); break;
                case 'ArrowRight': xFt = Math.min(12, xFt + step); e.preventDefault(); break;
                case '[': heading = (heading - 15 + 360) % 360; e.preventDefault(); break;
                case ']': heading = (heading + 15) % 360; e.preventDefault(); break;
                default: return;
            }

            document.getElementById('x-input-ft').value = xFt.toFixed(2);
            document.getElementById('y-input-ft').value = yFt.toFixed(2);
            document.getElementById('heading-input').value = Math.round(heading);
            updateRobot();
        });

        // Intake & Outtake Motor Controls
        let intakeState = 'stopped';
        let outtakeState = 'stopped';

        // Helper function to send commands to VEX brain via WebSocket/HTTP
        async function sendMotorCommand(motor, command) {
            try {
                // This assumes your VEX brain is running a simple HTTP server
                // Adjust the IP and port to match your robot's brain IP
                const response = await fetch(`http://192.168.1.100:8080/motor`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ motor: motor, command: command })
                });
                console.log(`${motor} ${command}:`, response.ok ? 'Success' : 'Failed');
            } catch (error) {
                console.log(`Motor command error (${motor} ${command}):`, error.message);
                console.log('Note: Make sure VEX brain is connected and running motor server');
            }
        }

        function intakeForward() {
            intakeState = 'forward';
            console.log('Intake: Forward');
            sendMotorCommand('intake', 'forward');
            updateMotorDisplay('Intake: Forward ▶');
        }

        function intakeReverse() {
            intakeState = 'reverse';
            console.log('Intake: Reverse');
            sendMotorCommand('intake', 'reverse');
            updateMotorDisplay('Intake: Reverse ◀');
        }

        function intakeStop() {
            intakeState = 'stopped';
            console.log('Intake: Stop');
            sendMotorCommand('intake', 'stop');
            updateMotorDisplay('Intake: Stopped');
        }

        function outtakeForward() {
            outtakeState = 'forward';
            console.log('Outtake: Forward');
            sendMotorCommand('outtake', 'forward');
            updateMotorDisplay('Outtake: Forward ▶');
        }

        function outtakeReverse() {
            outtakeState = 'reverse';
            console.log('Outtake: Reverse');
            sendMotorCommand('outtake', 'reverse');
            updateMotorDisplay('Outtake: Reverse ◀');
        }

        function outtakeStop() {
            outtakeState = 'stopped';
            console.log('Outtake: Stop');
            sendMotorCommand('outtake', 'stop');
            updateMotorDisplay('Outtake: Stopped');
        }

        function updateMotorDisplay(message) {
            // Optional: Update status on screen
            const dataDisplay = document.getElementById('data-output');
            if (dataDisplay) {
                dataDisplay.textContent = `Motor Command: ${message}`;
            }
        }
        // Initialize
        updateRobot();
        setFieldMode('skills');
    </script>
</body>
</html>